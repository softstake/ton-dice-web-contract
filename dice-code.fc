int parse_number(int x) {
    throw_if(35, (x < 48) | (x > 57));
    return x - 48;
}

int pow(int x, int y) {
    if (y == 0) {
        return 1;
    }
    int res = 1;
    do {
        y -= 1;
        res *= x;
    } until(y == 0);

    return res;
}

slice num_to_str(int x) {
  builder b = begin_cell();
  do {
    (x, int y) = x /% 10;
    builder b' = begin_cell().store_uint(y + 48, 8);
    b = concat_builders(b', b);
  } until (x == 0);
  return b.end_cell().begin_parse();
}

int str_to_num(slice s) {
  int res = 0;
  int cbits = slice_bits(s);
  int n = cbits / 8;
  do {
    n -= 1;
    int code = s~load_uint(8);
    int dig = parse_number(code);
    res += dig * pow(10, n);
  } until (n == 0);

  return res;
}

int is_sep(int code, int sep) inline_ref {
  if (code == sep) {
      return true;
  }
  return false;
}

(slice, int) slice_to_sep(slice s, int start) {
  int max = slice_bits(s);
  throw_if(42, start >= max);
  int offset = 0;
  do {
    int break = false; 
    slice tmp = sub_str(s, start + offset, 8);
    int code = tmp~load_uint(8);
    int sep? = is_sep(code, 44); ;; comma sep
    if (sep?) {
      break = true;
    } else {
      offset += 8;
    }
    if (start + offset >= max) {
      break = true;
    }
  } until (break);

  return (sub_str(s, start, offset), start + offset);
}

int slice_equal(s1, s2) {
  return slice_hash(s1) == slice_hash(s2);
}

slice decode(slice s) {
    int size = slice_bits(s);
    throw_if(40, size != 384);
    int count = size / 8;
    builder res = begin_cell();
    do {
        int num = s~load_uint(8);
        if ((num >= 65) & (num <= 90)) {
            num -= 65;
        } elseif ((num >= 97) & (num <= 122)) {
            num -= 71;
        } elseif ((num >= 48) & (num <= 57)) {
            num += 4;
        } elseif (num == 95) {
            num = 63;
        } elseif (num == 45) {
            num = 62;
        }
        res~store_uint(num, 6);
        count -= 1;
    } until(count == 0);
    return end_cell(res).begin_parse();
}

() send_message_back(slice addr, slice body, int grams, int mode) impure {
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_grams(grams)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(0, 32)
    .store_slice(body);
  send_raw_message(msg.end_cell(), mode);
}

(int, int, cell, int) load_data() {
  var ds = get_data().begin_parse();
  var res = (ds~load_uint(32), ds~load_uint(256), ds~load_dict(), ds~load_grams()); ;; seqno pubk queue lock
  ds.end_parse();
  return res;
}

int get_random_roll(slice sig) {
  int seed = slice_hash(sig);
  return seed % 100 + 1;
}

int calc_payout(int amount, int roll_under, int fee) {
  return amount * (100 - fee) / (roll_under - 1);
}

(slice, int) get_bet?(int id) {
  var (_, _, queue, _) = load_data();
  return queue.udict_get?(32, id);
}

() resolve_bet(int bet_id, slice sig) impure {
  var (stored_seqno, public_key, queue, locked) = load_data();
  var (bet, found) = get_bet?(bet_id);
  throw_unless(61, found);

  int roll_under = bet~load_uint(8);
  int amount = bet~load_grams();
  slice player_addr = bet~load_msg_addr();
  slice ref_addr = bet~load_msg_addr();
  int ref_bonus = bet~load_grams();
  int seed = bet~load_uint(256);
  throw_unless(34, check_signature(seed, sig, public_key));

  (queue, int ok) = queue.udict_delete?(32, bet_id);
  throw_unless(62, ok);

  accept_message();

  int fee = 2;
  if (ref_bonus > 0) {
    fee -= 1; ;; player bonus
  }

  int possible_payout = calc_payout(amount, roll_under, fee);
  int random_roll = get_random_roll(sig);

  int payout = 0;
  if (random_roll < roll_under) {
    payout += possible_payout;
    ;; "TONBET.IO - lucky number " - x{544F4E4245542E494F202D206C75636B79206E756D62657220} STSLICECONST
    ;; " fell for betting with id " - x{2066656C6C20666F722062657474696E67207769746820696420} STSLICECONST
    slice msg = begin_cell().store_uint(0x544F4E4245542E494F202D206C75636B79206E756D62657220, 200).store_slice(num_to_str(random_roll)).store_uint(0x2066656C6C20666F722062657474696E67207769746820696420, 208).store_slice(num_to_str(bet_id)).end_cell().begin_parse();
    send_message_back(player_addr, msg, payout, 2);
  } else {
    payout = 1;
    ;; "TONBET.IO - random roll " - x{544F4E4245542E494F202D2072616E646F6D20726F6C6C20} STSLICECONST
    ;; " fell for betting with id " - x{2066656C6C20666F722062657474696E67207769746820696420} STSLICECONST
    slice msg = begin_cell().store_uint(0x544F4E4245542E494F202D2072616E646F6D20726F6C6C20, 192).store_slice(num_to_str(random_roll)).store_uint(0x2066656C6C20666F722062657474696E67207769746820696420, 208).store_slice(num_to_str(bet_id)).end_cell().begin_parse();
    send_message_back(player_addr, msg, payout, 1);
  }

  if (ref_bonus > 0) {
    ;; "Play on TONBET.IO" - x{506C6179206F6E20544F4E4245542E494F} STSLICECONST
    slice msg = begin_cell().store_uint(0x506C6179206F6E20544F4E4245542E494F, 136).end_cell().begin_parse();
    send_message_back(ref_addr, msg, ref_bonus, 2);
    locked -= ref_bonus;
  }

  locked -= possible_payout;

  return set_data(begin_cell().store_uint(stored_seqno + 1, 32).store_uint(public_key, 256).store_dict(queue).store_grams(locked).end_cell());
}

() add_to_queue(int bet_id, slice s, int seed, int payout) impure {
  var (stored_seqno, public_key, queue, locked) = load_data();
  int ok = queue~udict_add_builder?(32, bet_id, begin_cell()
    .store_slice(s)
    .store_uint(seed, 256));
  throw_unless(61, ok);
  set_data(begin_cell().store_uint(stored_seqno, 32).store_uint(public_key, 256).store_dict(queue).store_grams(locked + payout).end_cell());
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
  var cs = in_msg_cell.begin_parse();
  var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  var s_addr = cs~load_msg_addr();

  int size = slice_bits(in_msg);
  if (size < 33) {
    throw_if(0, true);
  }

  if (msg_value < 100000000) {
    ;; "TONBET.IO - min bet is 0.1" - x{544F4E4245542E494F202D206D696E2062657420697320302E31}
    slice msg = begin_cell().store_uint(0x544F4E4245542E494F202D206D696E2062657420697320302E31, 208).end_cell().begin_parse();
    send_message_back(s_addr, msg, 0, 64);
    return ();
  }

  var (part1, n) = slice_to_sep(in_msg, 32); ;; roll_under
  var (part2, n) = slice_to_sep(in_msg, n + 8); ;; bet_id
  n += 8;

  int fee = 2;
  int ref_bonus = 0;
  slice ref_addr = my_address();
  if (n < size) {
    (_, cell ref) = load_ref(in_msg);
    int size_ref = ref.begin_parse().slice_bits();
    int valid_size = size - n + size_ref;
    throw_if(40, valid_size != 384);

    var (part3, _) = slice_to_sep(in_msg, n);
    var addr = begin_cell().store_slice(part3).store_slice(ref.begin_parse()).end_cell().begin_parse();

    slice res = decode(addr);
    res~skip_bits(8);
    slice wc = first_bits(res, 2);
    res~skip_bits(8);
    res~skip_last_bits(16);

    ;; b{1000100} STSLICECONST
    slice possible_ref_addr = begin_cell().store_uint(68, 7).store_int(wc~load_int(2), 8).store_slice(res).end_cell().begin_parse();
    possible_ref_addr~skip_bits(4);

    ifnot (slice_equal(possible_ref_addr, s_addr) & slice_equal(possible_ref_addr, my_address())) {
      ref_addr = possible_ref_addr;
      fee -= 1; ;; player bonus
      ref_bonus = msg_value * 5 / 1000;
    }
  }

  int roll_under = str_to_num(part1);
  throw_if(40, (roll_under < 2) | (roll_under > 96));
  int bet_id = str_to_num(part2);
  throw_if(41, bet_id > 9999);

  var (_, _, _, locked) = load_data();
  int bank = first(get_balance());
  int possible_payout = calc_payout(msg_value, roll_under, fee);

  int liabilities = possible_payout + ref_bonus + locked;
  int available_balance = bank - liabilities;

  ;; "TONBET.IO - fund overflow" - x{544F4E4245542E494F202D2066756E64206F766572666C6F77}
  slice msg = begin_cell().store_uint(0x544F4E4245542E494F202D2066756E64206F766572666C6F77, 200).end_cell().begin_parse();

  if (available_balance < 0) {
    send_message_back(s_addr, msg, 0, 64);
    return ();
  }

  int max_win = available_balance / 4;
  if (possible_payout >= max_win) {
    send_message_back(s_addr, msg, 0, 64);
    return ();
  }

  slice s = begin_cell()
      .store_uint(roll_under, 8)
      .store_grams(msg_value)
      .store_slice(s_addr)
      .store_slice(ref_addr)
      .store_grams(ref_bonus)
    .end_cell().begin_parse();
    
  randomize_lt();
  randomize(slice_hash(begin_cell()
      .store_uint(bet_id, 32)
      .store_slice(s)
    .end_cell().begin_parse()));

  int rand_seed = random();
  return add_to_queue(bet_id, s, rand_seed, liabilities - locked);
}

() recv_external(slice in_msg) impure {
  var (stored_seqno, public_key, queue, locked) = load_data();
  var signature = in_msg~load_bits(512);
  var cs = in_msg~load_ref().begin_parse();
  throw_unless(34, check_signature(slice_hash(cs), signature, public_key)); ;; owner check
  int msg_seqno = cs~load_uint(32);
  throw_unless(33, msg_seqno == stored_seqno);

  int op = cs~load_uint(32);
  if (op == 0x11111111) {
      ;; init
      accept_message();
      set_data(begin_cell().store_uint(stored_seqno + 1, 32).store_uint(public_key, 256).store_dict(queue).store_grams(locked).end_cell());
      return ();
  }
  if (op == 0x22222222) {
    ;; resolve bet
    int bet_id = cs~load_uint(32);
    slice sig = cs~load_bits(512);

    return resolve_bet(bet_id, sig);
  }
  if (op == 0x33333333) {
    ;; upgrade code
    var code = cs~load_ref();
    accept_message();
    set_code(code);
  }
}

;; Get methods

int get_seqno() method_id {
  (int stored_seqno, _, _, _) = load_data();
  return stored_seqno;
}

int get_bet_seed(int bet_id) method_id {
    var (bet, found) = get_bet?(bet_id);
    throw_unless(61, found);
    (_, _, _, _, _, int seed) = (bet~load_uint(8), bet~load_grams(), bet~load_msg_addr(), bet~load_msg_addr(), bet~load_grams(), bet~load_uint(256));
    return seed;
}

int get_liabilities() method_id {
  (_, _, _, int locked) = load_data();
  return locked;
}