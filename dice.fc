;; Standard library for funC
;;

forall X -> tuple cons(X head, tuple tail) asm "CONS";
forall X -> (X, tuple) uncons(tuple list) asm "UNCONS";
forall X -> (tuple, X) list_next(tuple list) asm( -> 1 0) "UNCONS";
forall X -> X car(tuple list) asm "CAR";
tuple cdr(tuple list) asm "CDR";
forall X, Y -> tuple pair(X x, Y y) asm "PAIR";
forall X, Y -> (X, Y) unpair(tuple t) asm "UNPAIR";
forall X, Y, Z -> tuple triple(X x, Y y, Z z) asm "TRIPLE";
forall X, Y, Z -> (X, Y, Z) untriple(tuple t) asm "UNTRIPLE";
forall X, Y, Z, W -> tuple tuple4(X x, Y y, Z z, W w) asm "4 TUPLE";
forall X, Y, Z, W -> (X, Y, Z, W) untuple4(tuple t) asm "4 UNTUPLE";
forall X -> X first(tuple t) asm "FIRST";
forall X -> X second(tuple t) asm "SECOND";
forall X -> X third(tuple t) asm "THIRD";
forall X -> X fourth(tuple t) asm "3 INDEX";
forall X -> X null() asm "PUSHNULL";

int now() asm "NOW";
slice my_address() asm "MYADDR";
tuple get_balance() asm "BALANCE";
int cur_lt() asm "LTIME";
int block_lt() asm "BLOCKLT";

int cell_hash(cell c) asm "HASHCU";
int slice_hash(slice s) asm "HASHSU";
int string_hash(slice s) asm "SHA256U";

int check_signature(int hash, slice signature, int public_key) asm "CHKSIGNU";
int check_data_signature(slice data, slice signature, int public_key) asm "CHKSIGNS";

;; () throw_if(int excno, int cond) impure asm "THROWARGIF";

() dump_stack() impure asm "DUMPSTK";

cell get_data() asm "c4 PUSH";
() set_data(cell c) impure asm "c4 POP";
cont get_c3() impure asm "c3 PUSH";
() set_c3(cont c) impure asm "c3 POP";
cont bless(slice s) impure asm "BLESS";

() accept_message() impure asm "ACCEPT";
() set_gas_limit(int limit) impure asm "SETGASLIMIT";
() commit() impure asm "COMMIT";

int min(int x, int y) asm "MIN";
int max(int x, int y) asm "MAX";

slice begin_parse(cell c) asm "CTOS";
() end_parse(slice s) impure asm "ENDS";
(slice, cell) load_ref(slice s) asm( -> 1 0) "LDREF";
cell preload_ref(slice s) asm "PLDREF";
;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) "LDIX";
;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) "LDUX";
;; int preload_int(slice s, int len) asm "PLDIX";
;; int preload_uint(slice s, int len) asm "PLDUX";
;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) "LDSLICEX";
;; slice preload_bits(slice s, int len) asm "PLDSLICEX";
(slice, int) load_grams(slice s) asm( -> 1 0) "LDGRAMS";
slice skip_bits(slice s, int len) asm "SDSKIPFIRST";
(slice, ()) ~skip_bits(slice s, int len) asm "SDSKIPFIRST";
slice first_bits(slice s, int len) asm "SDCUTFIRST";
slice skip_last_bits(slice s, int len) asm "SDSKIPLAST";
(slice, ()) ~skip_last_bits(slice s, int len) asm "SDSKIPLAST";
slice sub_str(slice, int, int) asm "SDSUBSTR";
(slice, cell) load_dict(slice s) asm( -> 1 0) "LDDICT";
cell preload_dict(slice s) asm "PLDDICT";
slice skip_dict(slice s) asm "SKIPDICT";

int slice_refs(slice s) asm "SREFS";
int slice_bits(slice s) asm "SBITS";
(int, int) slice_bits_refs(slice s) asm "SBITREFS";
int slice_empty?(slice s) asm "SEMPTY";
int slice_data_empty?(slice s) asm "SDEMPTY";
int slice_refs_empty?(slice s) asm "SREMPTY";

builder begin_cell() asm "NEWC";
cell end_cell(builder b) asm "ENDC";
builder store_ref(builder b, cell c) asm(c b) "STREF";
;; builder store_uint(builder b, int x, int len) asm(x b len) "STUX";
;; builder store_int(builder b, int x, int len) asm(x b len) "STIX";
builder store_slice(builder b, slice s) asm "STSLICER";
builder store_grams(builder b, int x) asm "STGRAMS";
builder store_dict(builder b, cell c) asm(c b) "STDICT";

(slice, slice) load_msg_addr(slice s) asm( -> 1 0) "LDMSGADDR";
tuple parse_addr(slice s) asm "PARSEMSGADDR";
(int, int) parse_std_addr(slice s) asm "REWRITESTDADDR";
(int, slice) parse_var_addr(slice s) asm "REWRITEVARADDR";

cell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
cell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
cell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGETOPTREF";
cell udict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGETOPTREF";
(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETGETOPTREF";
(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETGETOPTREF";
(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDEL";
(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDEL";
(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGET" "NULLSWAPIFNOT";
(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "NULLSWAPIFNOT";
(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
cell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
cell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
cell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUADD";
(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUREPLACE";
(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIADD";
(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIREPLACE";
cell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";
(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";
cell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
cell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUADDB";
(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUREPLACEB";
(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIADDB";
(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIREPLACEB";
(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXT" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXTEQ" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREV" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREVEQ" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXT" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXTEQ" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREV" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREVEQ" "NULLSWAPIFNOT" "NULLSWAPIFNOT";
cell new_dict() asm "NEWDICT";
int dict_empty?(cell c) asm "DICTEMPTY";

cell config_param(int x) asm "CONFIGOPTPARAM";
int cell_null?(cell c) asm "ISNULL";

() raw_reserve(int amount, int mode) impure asm "RAWRESERVE";
() raw_reserve_extra(slice currencies, int mode) impure asm "RAWRESERVEX";
() send_raw_message(cell msg, int mode) impure asm "SENDRAWMSG";
() set_code(cell new_code) impure asm "SETCODE";

int random() impure asm "RANDU256";
int rand(int range) impure asm "RAND";
int get_seed() impure asm "RANDSEED";
int set_seed() impure asm "SETRAND";
() randomize(int x) impure asm "ADDRAND";
() randomize_lt() impure asm "LTIME" "ADDRAND";

int parse_number(int x) {
    throw_if(35, (x < 48) | (x > 57));
    return x - 48;
}

int pow(int x, int y) {
    if (y == 0) {
        return 1;
    }
    int res = 1;
    do {
        y -= 1;
        res *= x;
    } until(y == 0);

    return res;
}

int str_to_num(slice s) {
  int res = 0;
  int cbits = slice_bits(s);
  int n = cbits / 8;
  do {
    n -= 1;
    int code = s~load_uint(8);
    int dig = parse_number(code);
    res += dig * pow(10, n); 
  } until (n == 0);

  return res;
}

int is_sep(int code, int sep) inline_ref {
  if (code == sep) {
      return true;
  }
  return false;
}

(slice, int) slice_to_sep(slice s, int start) {
  int max = slice_bits(s);
  throw_if(42, start >= max);
  int offset = 0;
  do {
    int break = false;
    slice tmp = sub_str(s, start + offset, 8);
    int code = tmp~load_uint(8);
    int sep? = is_sep(code, 44); ;; comma sep
    if (sep?) {
      break = true;
    } else {
      offset += 8;
    }
    if (start + offset >= max) {
      break = true;
    }
  } until (break);

  return (sub_str(s, start, offset), start + offset);
}

slice decode(slice s) {
    int size = slice_bits(s);
    throw_if(40, size != 384);
    int count = size / 8;
    builder res = begin_cell();
    do {
        int num = s~load_uint(8);
        if ((num >= 65) & (num <= 90)) {
            num -= 65;
        } elseif ((num >= 97) & (num <= 122)) {
            num -= 71;
        } elseif ((num >= 48) & (num <= 57)) {
            num += 4;
        } elseif (num == 95) {
            num = 63;
        } elseif (num == 45) {
            num = 62;
        }
        res~store_uint(num, 6);
        count -= 1;
    } until(count == 0);
    return end_cell(res).begin_parse();
}

() send_message_back(slice addr, slice body, int grams, int mode) impure {
  var msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(addr)
    .store_grams(grams)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(0, 32)
    .store_slice(body);
  send_raw_message(msg.end_cell(), mode);
}

(int, int, cell, int) load_data() {
  var ds = get_data().begin_parse();
  var res = (ds~load_uint(32), ds~load_uint(256), ds~load_dict(), ds~load_grams()); ;; seqno pubk queue lock
  ds.end_parse();
  return res;
}

int get_random_roll(slice sig) {
  int seed = slice_hash(sig);
  return seed % 12 + 1;
}

int calc_payout(int amount, int roll_under) {
  return amount * 11 / (roll_under - 1);
}

(slice, int) get_bet?(int id) {
  var (_, _, queue, _) = load_data();
  return queue.udict_get?(32, id);
}

() resolve_bet(int bet_id, slice sig) impure {
  var (stored_seqno, public_key, queue, locked) = load_data();
  var (bet, found) = get_bet?(bet_id);
  throw_unless(61, found);

  int roll_under = bet~load_uint(8);
  int amount = bet~load_grams();
  slice player_addr = bet~load_msg_addr();

  int seed = bet~load_uint(256);
  throw_unless(34, check_signature(seed, sig, public_key));

  (queue, int ok) = queue.udict_delete?(32, bet_id);
  throw_unless(62, ok); 

  accept_message();

  int possible_payout = calc_payout(amount, roll_under); ;; without guarantee
  int random_roll = get_random_roll(sig);

  int payout = 1000000000; ;; guarantee
  if (random_roll < roll_under) {
    payout += possible_payout; ;; with guarantee
  }

  slice msg = begin_cell().store_uint(bet_id, 32).store_uint(roll_under, 8).end_cell().begin_parse();
  send_message_back(player_addr, msg, payout, 2);
  locked -= 1000000000;
  locked -= possible_payout;

  return set_data(begin_cell().store_uint(stored_seqno + 1, 32).store_uint(public_key, 256).store_dict(queue).store_grams(locked).end_cell());
}

() add_to_queue(int bet_id, slice s, int seed, int payout) impure {
  var (stored_seqno, public_key, queue, locked) = load_data();
  int ok = queue~udict_add_builder?(32, bet_id, begin_cell()
    .store_slice(s)
    .store_uint(seed, 256));
  throw_unless(61, ok);
  set_data(begin_cell().store_uint(stored_seqno, 32).store_uint(public_key, 256).store_dict(queue).store_grams(locked + payout).end_cell());
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
  var cs = in_msg_cell.begin_parse();
  var flags = cs~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  var s_addr = cs~load_msg_addr();

  (slice remainder, cell ref) = load_ref(in_msg);
  var (part1, n) = slice_to_sep(remainder, 32);
  var (part2, n) = slice_to_sep(remainder, n + 8);
  var (part3, _) = slice_to_sep(remainder, n + 8);

  int roll_under = str_to_num(part1);
  throw_if(40, (roll_under < 2) | (roll_under > 11));
  int bet_id = str_to_num(part2);
  throw_if(41, bet_id > 9999);

  var addr = begin_cell().store_slice(part3).store_slice(ref.begin_parse()).end_cell().begin_parse();
  slice res = decode(addr);
  res~skip_bits(8);
  slice wc = first_bits(res, 2);
  res~skip_bits(8);
  res~skip_last_bits(16);

  slice ref_addr = begin_cell().store_int(wc~load_int(2), 8).store_slice(res).end_cell().begin_parse();
  ref_addr~skip_bits(4);

  var (_, _, _, locked) = load_data();
  int bank = first(get_balance());
  int pure_amt = msg_value - 1000000000; ;; without guarantee
  int possible_payout = calc_payout(pure_amt, roll_under);
  int liabilities = possible_payout + locked + 1000000000; ;; with guarantee
  if (bank < liabilities) {
      slice msg = begin_cell().store_uint(bet_id, 32).end_cell().begin_parse();
      send_message_back(s_addr, msg, 0, 64);
      return ();
  }

  slice s = begin_cell()
      .store_uint(roll_under, 8)
      .store_grams(pure_amt)
      .store_slice(s_addr)
      .store_slice(ref_addr)
    .end_cell().begin_parse();
    
  randomize_lt();
  randomize(slice_hash(begin_cell()
      .store_uint(bet_id, 32)
      .store_slice(s)
    .end_cell().begin_parse()));

  int rand_seed = random();
  return add_to_queue(bet_id, s, rand_seed, liabilities - locked);
}

() recv_external(slice in_msg) impure {
  var (stored_seqno, public_key, queue, locked) = load_data();
  var signature = in_msg~load_bits(512);
  var cs = in_msg~load_ref().begin_parse();
  throw_unless(34, check_signature(slice_hash(cs), signature, public_key)); ;; owner check
  int msg_seqno = cs~load_uint(32);
  throw_unless(33, msg_seqno == stored_seqno);

  int op = cs~load_uint(32);
  if (op == 0x11111111) {
      ;; init
      accept_message();
      set_data(begin_cell().store_uint(stored_seqno + 1, 32).store_uint(public_key, 256).store_dict(queue).store_grams(locked).end_cell());
      return ();
  }
  if (op == 0x22222222) {
    ;; resolve bet
    int bet_id = cs~load_uint(32);
    var sig = cs~load_bits(512);

    return resolve_bet(bet_id, sig);
  }
  if (op == 0x33333333) {
    ;; upgrade code
    var code = cs~load_ref();
    accept_message();
    set_code(code);
  }
}

;; Get methods

int get_seqno() method_id {
  (int stored_seqno, _, _, _) = load_data();
  return stored_seqno;
}

int get_bet_seed(int bet_id) method_id {
    var (bet, found) = get_bet?(bet_id);
    throw_unless(61, found);
    (_, _, _, int seed) = (bet~load_uint(8), bet~load_grams(), bet~load_msg_addr(), bet~load_uint(256));
    return seed;
}

int get_liabilities() method_id {
  (_, _, _, int locked) = load_data();
  return locked;
}